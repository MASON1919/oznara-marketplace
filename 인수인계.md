# 프로젝트 인수 인계서 - 실시간 채팅 기능 구현

## 1. 프로젝트 개요

*   **프로젝트명:** 팀 프로젝트 (중고나라 마켓플레이스)
*   **작업명:** 제품 상세 페이지 채팅 기능 구현 및 알림 준비
*   **작업자:** Gemini (AI 어시스턴트)
*   **작업 기간:** 2025년 10월 29일 ~ 현재
*   **작업 목표:**
    *   제품 상세 페이지에 판매자와 구매자 간 1:1 채팅 기능 도입.
    *   기존 데이터베이스(PostgreSQL via Prisma) 스키마 변경 없이 Firebase Firestore를 활용하여 채팅 데이터 관리.
    *   Next.js 15 환경 및 기존 프로젝트 기술 스택(NextAuth, React Hooks, shadcn/ui 등) 준수.
    *   판매자에게 새로운 메시지 알림을 제공하기 위한 기반 마련.

## 2. 구현 아키텍처 및 기술 스택

*   **프론트엔드:** Next.js 15 (App Router 기반), React, Tailwind CSS, shadcn/ui, NextAuth.js
*   **백엔드:** Next.js Server Actions/API Routes
*   **데이터베이스:**
    *   **PostgreSQL (via Prisma):** 사용자, 상품(Listing) 등 기존 핵심 비즈니스 데이터 관리.
    *   **Firebase Firestore:**
        *   실시간 채팅 메시지 저장 및 동기화.
        *   채팅방 정보(참여자, 마지막 메시지 시간, 마지막 읽은 시간) 저장 및 관리.
        *   (*PostgreSQL 스키마를 변경하지 않기 위한 전략적 선택*)
*   **인증:** NextAuth.js (클라이언트 및 서버에서 세션 정보 활용)
*   **실시간 통신:** Firebase Firestore `onSnapshot`

## 3. 파일별 상세 구현 내용

### 3.1. `.env.local` 파일 생성 및 설정

*   **파일 경로:** `/Users/admin/Desktop/bootcamp/teamproject/team-1-react/.env.local`
*   **변경/생성 전 요약:** Firebase 관련 환경 변수 없음.
*   **변경/생성 후 요약:** Firebase 프로젝트 설정에서 가져온 키들을 저장.
*   **주요 변경 코드:**
    ```ini
    # Firebase 설정 (주의: 실제 값으로 교체되어야 하며, 공개되지 않아야 함!)
    NEXT_PUBLIC_FIREBASE_API_KEY="YOUR_API_KEY"
    NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="YOUR_AUTH_DOMAIN"
    NEXT_PUBLIC_FIREBASE_PROJECT_ID="YOUR_PROJECT_ID"
    NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="YOUR_STORAGE_BUCKET"
    NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="YOUR_MESSAGING_SENDER_ID"
    NEXT_PUBLIC_FIREBASE_APP_ID="YOUR_APP_ID"
    ```
*   **변경/생성 이유:**
    *   Firebase 서비스를 사용하기 위한 필수 인증 정보.
    *   `NEXT_PUBLIC_` 접두사를 사용하여 클라이언트 측 코드(`src/lib/firebase.js`)에서도 안전하게 접근 가능하도록 함.
    *   보안 강화를 위해 환경 변수 사용을 권장하며, 실제 값은 `.env.local` 파일에만 저장되어야 함. (**주의**: 이 정보는 절대 GitHub 등에 공개되어서는 안 됩니다. 현재 노출된 키는 즉시 교체해야 합니다.)

### 3.2. `src/lib/firebase.js` 파일 생성

*   **파일 경로:** `/Users/admin/Desktop/bootcamp/teamproject/team-1-react/src/lib/firebase.js`
*   **변경/생성 전 요약:** Firebase 관련 초기화 파일 없음.
*   **변경/생성 후 요약:** Firebase 앱을 초기화하고 Firestore 인스턴스를 export하는 파일.
*   **주요 변경 코드:**
    ```javascript
    // Firebase SDK에서 필요한 함수들을 import 합니다.
    import { initializeApp, getApps, getApp } from "firebase/app";
    import { getFirestore } from "firebase/firestore"; // Firestore 데이터베이스 서비스를 사용하기 위해 import 합니다.

    // .env.local 파일에 정의된 환경 변수에서 Firebase 설정 정보를 가져옵니다.
    // NEXT_PUBLIC_ 접두사는 클라이언트 측 코드에서도 이 변수들에 접근할 수 있도록 합니다.
    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    };

    // Firebase 앱을 초기화합니다.
    // 이미 초기화된 앱이 있다면 해당 앱을 사용하고, 없다면 새로 초기화합니다.
    // 이는 Next.js의 개발 모드에서 핫 리로딩 시 앱이 중복 초기화되는 것을 방지합니다.
    const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

    // 초기화된 Firebase 앱에서 Firestore 데이터베이스 인스턴스를 가져옵니다.
    const db = getFirestore(app);

    // 다른 파일에서 Firebase 앱과 Firestore 데이터베이스 인스턴스를 사용할 수 있도록 export 합니다.
    export { app, db };
    ```
*   **변경/생성 이유:**
    *   애플리케이션 전반에서 Firebase 및 Firestore를 일관성 있게 사용할 수 있도록 단일 진입점(Entry Point) 제공.
    *   Next.js의 개발 모드에서 핫 리로딩 시 Firebase 앱이 중복 초기화되는 문제를 `getApps().length`로 방지.

### 3.3. `src/app/api/chat/initiate/route.js` 파일 생성 및 수정

*   **파일 경로:** `/Users/admin/Desktop/bootcamp/teamproject/team-1-react/src/app/api/chat/initiate/route.js`
*   **변경/생성 전 요약:** 채팅방 시작 요청을 처리하는 API 라우트 없음.
*   **변경/생성 후 요약:** 구매자-판매자 간 1:1 채팅방을 Firestore에서 조회하거나 새로 생성하고, 채팅방 ID를 반환하는 API.
*   **주요 변경 코드:**
    ```javascript
    // Next.js 서버 응답을 위한 유틸리티와 NextAuth 세션 관리를 위한 함수들을 import 합니다.
    import { NextResponse } from "next/server";
    import { getServerSession } from "next-auth";
    import { authOptions } from "@/app/api/auth/[...nextauth]/route";

    // Firebase Firestore 인스턴스 및 관련 함수들을 import 합니다.
    import { db } from "@/lib/firebase";
    import {
      collection,
      doc,
      getDoc,
      setDoc,
      serverTimestamp,
    } from "firebase/firestore";

    // POST 요청을 처리하는 함수입니다. 클라이언트에서 채팅 시작 요청을 받습니다.
    export async function POST(request) {
      // NextAuth를 사용하여 현재 로그인된 사용자의 세션 정보를 가져옵니다.
      const session = await getServerSession(authOptions);

      // 세션 정보가 없으면 (로그인되지 않은 사용자) 401 Unauthorized 응답을 반환합니다.
    if (!session) {
        return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
      }

      // 요청 본문에서 판매자 ID를 가져옵니다.
      const { sellerId } = await request.json();
      // 로그인된 사용자의 ID를 구매자 ID로 설정합니다.
      const buyerId = session.user.id;

      // 판매자 ID가 제공되지 않았으면 400 Bad Request 응답을 반환합니다.
      if (!sellerId) {
        return NextResponse.json(
          { error: "Seller ID is required" },
          { status: 400 }
        );
      }

      // 판매자 ID와 구매자 ID가 같으면 (자신과 채팅 시도) 400 Bad Request 응답을 반환합니다.
      if (sellerId === buyerId) {
        return NextResponse.json(
          { error: "Cannot start chat with yourself" },
          { status: 400 }
        );
      }

      // 구매자 ID와 판매자 ID를 정렬하여 고유한 채팅방 ID를 생성합니다.
      // 이렇게 하면 두 사용자 간의 채팅방은 항상 동일한 ID를 가지게 됩니다.
      // 예: "userA-userB" 또는 "userB-userA" 모두 "userA_id-userB_id"가 됩니다.
      const chatRoomId = [buyerId, sellerId].sort().join("-");

      try {
        // Firestore에서 해당 chatRoomId를 가진 문서(채팅방)의 참조를 가져옵니다.
        const chatRoomRef = doc(db, "chatrooms", chatRoomId);
        // 해당 채팅방 문서의 스냅샷을 가져옵니다.
        const chatRoomSnap = await getDoc(chatRoomRef);

        // 채팅방이 존재하지 않으면 새로 생성합니다.
        if (!chatRoomSnap.exists()) {
          await setDoc(chatRoomRef, {
            participants: [buyerId, sellerId], // 채팅방 참여자 ID 목록
            createdAt: serverTimestamp(),      // Firestore 서버 타임스탬프 (생성 시간)
            lastMessageTimestamp: serverTimestamp(), // 새로운 채팅방 생성 시 마지막 메시지 시간 초기화 (알림용)
            lastRead: {                        // 각 참여자의 마지막 읽은 시간 초기화 (알림용)
              [buyerId]: serverTimestamp(),
              [sellerId]: serverTimestamp(),
            },
          });
        }

        // 성공적으로 채팅방 ID를 반환합니다.
        return NextResponse.json({ chatRoomId }, { status: 200 });
      } catch (error) {
        // 에러 발생 시 콘솔에 에러를 기록하고 500 Internal Server Error 응답을 반환합니다.
        console.error("Error initiating chat room:", error);
        return NextResponse.json(
          { error: "Failed to initiate chat room", details: error.message },
          { status: 500 }
        );
      }
    }
    ```
*   **변경/생성 이유:**
    *   클라이언트(ChatButton)에서 채팅 시작 요청 시, 서버를 통해 인증 및 채팅방 관리를 수행.
    *   기존 PostgreSQL 스키마 변경 없이 Firestore를 채팅방 메타데이터 저장소로 활용.
    *   두 사용자 간의 채팅방이 하나만 존재하도록 고유 ID 생성 로직 구현.
    *   읽지 않은 메시지 알림 기능을 위한 `lastMessageTimestamp` 및 `lastRead` 필드 초기화.

### 3.4. `src/components/ChatButton.js` 파일 생성 및 수정

*   **파일 경로:** `/Users/admin/Desktop/bootcamp/teamproject/team-1-react/src/components/ChatButton.js`
*   **변경/생성 전 요약:** 채팅 시작 버튼 컴포넌트 없음.
*   **변경/생성 후 요약:** 제품 상세 페이지에 표시되는 '채팅하기' 버튼으로, 사용자의 인증 상태와 역할에 따라 조건부 렌더링되며, 클릭 시 채팅 시작 API를 호출하고 채팅 페이지로 이동.
*   **주요 변경 코드:**
    ```javascript
    // 이 컴포넌트는 클라이언트 측에서 렌더링됩니다.
    'use client';

    // React 훅과 Next.js 관련 훅, shadcn/ui 버튼 컴포넌트를 import 합니다.
    import { useState } from 'react';
    import { useSession } from 'next-auth/react'; // NextAuth 세션 정보를 가져오기 위해 사용합니다.
    import { useRouter } from 'next/navigation'; // 페이지 라우팅을 위해 사용합니다.
    import { Button } from '@/components/ui/button'; // shadcn/ui의 Button 컴포넌트를 가져옵니다.

    // ChatButton 컴포넌트는 판매자 ID를 props로 받습니다.
    export default function ChatButton({ sellerId }) {
      // useSession 훅을 사용하여 현재 사용자의 세션 정보와 인증 상태를 가져옵니다.
      const { data: session, status } = useSession();
      const router = useRouter(); // useRouter 훅을 사용하여 라우터 객체를 가져옵니다.
      const [isLoading, setIsLoading] = useState(false); // 버튼 로딩 상태를 관리합니다.

      // 세션 로딩 중일 때는 버튼을 렌더링하지 않아 깜빡임 현상을 방지합니다.
      if (status === 'loading') {
        return null;
      }

      // 로그인된 상태에서 현재 사용자가 판매자 본인일 경우 버튼을 숨깁니다.
      // 판매자는 자신의 상품에 대해 채팅을 시작할 필요가 없기 때문입니다.
      if (status === 'authenticated' && session.user.id === sellerId) {
        return null;
      }

      // '채팅하기' 버튼 클릭 시 실행될 비동기 함수입니다.
      const handleChatInitiation = async () => {
        // 로그인되지 않은 상태에서 버튼을 클릭하면 로그인 페이지로 리디렉션합니다.
        if (status !== 'authenticated') {
          router.push('/login');
          return;
        }

        setIsLoading(true); // 로딩 상태를 true로 설정하여 버튼을 비활성화하고 텍스트를 변경합니다.
        try {
          // /api/chat/initiate API 라우트로 POST 요청을 보냅니다.
          // 이 API는 Firestore에서 채팅방을 찾거나 새로 생성합니다.
          const response = await fetch('/api/chat/initiate', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ sellerId }), // 판매자 ID를 요청 본문에 담아 보냅니다.
          });

          // API 응답이 성공적이지 않으면 에러를 발생시킵니다.
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to start chat');
          }

          // API 응답에서 chatRoomId를 추출합니다.
          const { chatRoomId } = await response.json();
          
          // 채팅방 ID를 받아오면 해당 채팅 페이지로 이동합니다.
          router.push(`/chat/${chatRoomId}`);

        } catch (error) {
          console.error(error); // 콘솔에 에러를 기록합니다.
          alert(`오류: ${error.message}`); // 사용자에게 에러 메시지를 알립니다.
        } finally {
          setIsLoading(false); // 로딩 상태를 false로 설정합니다.
        }
      };

      // 컴포넌트 렌더링 부분입니다.
      return (
        <Button
          onClick={handleChatInitiation} // 클릭 이벤트 핸들러를 연결합니다.
          disabled={isLoading || status === 'loading'} // 로딩 중이거나 세션 로딩 중일 때 버튼을 비활성화합니다.
          className="w-full mt-4" // Tailwind CSS 클래스를 적용합니다.
          size="lg" // shadcn/ui 버튼의 크기를 설정합니다.
        >
          {isLoading ? '채팅방 여는 중...' : '채팅하기'} {/* 로딩 상태에 따라 버튼 텍스트를 변경합니다. */}
        </Button>
      );
    }
    ```
*   **변경/생성 이유:**
    *   제품 상세 페이지에서 채팅을 시작하는 진입점 역할.
    *   NextAuth 세션 (`useSession`)을 활용하여 사용자의 인증 상태에 따른 적절한 UI(로그인 페이지 리디렉션) 및 동작 제어.
    *   판매자 본인이 자신의 상품 페이지를 볼 때는 채팅하기 버튼이 보이지 않도록 UX 개선.
    *   API 호출을 통해 서버 측 채팅방 생성/조회 로직과 클라이언트 측 UI 로직 분리.

### 3.5. `src/app/listings/[id]/page.js` 파일 수정

*   **파일 경로:** `/Users/admin/Desktop/bootcamp/teamproject/team-1-react/src/app/listings/[id]/page.js`
*   **변경/생성 전 요약:** `ChatButton` 컴포넌트 없음.
*   **변경/생성 후 요약:** `ChatButton` 컴포넌트를 import하고, `ListingDescription` 컴포넌트 아래에 렌더링.
*   **주요 변경 코드:**
    ```javascript
    import { prisma } from "@/lib/prisma";
    import { getS3Url } from "@/lib/s3";
    import { getServerSession } from "next-auth";
    import { authOptions } from "@/app/api/auth/[...nextauth]/route";

    // 컴포넌트들을 import 합니다.
    import ListingCarousel from "@/components/ListingPage/ListingCarousel";
    import PurchaseForm from "@/components/ListingPage/PurchaseForm";
    import ListingDescription from "@/components/ListingPage/ListingDescription";
    import ChatButton from "@/components/ChatButton"; // 새로 추가된 채팅 버튼 컴포넌트

    // 상품 상세 페이지 컴포넌트입니다. 서버 컴포넌트로 동작합니다.
    export default async function ListingPage({ params }) {
      // URL 파라미터에서 상품 ID를 가져옵니다.
      const { id } = await params;
      // NextAuth를 사용하여 현재 로그인된 사용자의 세션 정보를 서버에서 가져옵니다.
      const session = await getServerSession(authOptions);
      // 로그인된 사용자의 ID를 가져오거나, 로그인되지 않았다면 null로 설정합니다.
      const userId = session?.user?.id ?? null;

      // Prisma를 사용하여 데이터베이스에서 상품 정보를 가져옵니다.
      // 상품 이미지와 사용자의 좋아요 여부도 함께 포함합니다.
      const listingInfo = await prisma.listing.findUnique({
        where: { id },
        include: {
          listingImages: {
            select: { s3Key: true },
          },
          likes: userId
            ? { // 사용자가 로그인되어 있다면 좋아요 여부를 확인합니다.
                where: { userId: userId },
                select: { userId: true },
                take: 1,
              }
            : false, // 로그인되어 있지 않다면 좋아요 정보를 가져오지 않습니다.
        },
      });

      // S3 키를 사용하여 이미지 URL을 생성합니다.
      const s3Urls = listingInfo.listingImages.map((image) =>
        getS3Url(image.s3Key)
      );

      // 좋아요 정보가 undefined일 경우 빈 배열로 초기화합니다.
      if (listingInfo.likes === undefined) {
        listingInfo.likes = [];
      }

      // 상품 정보가 없을 경우 에러 메시지를 표시합니다.
      if (!listingInfo) {
        return <div>상품 정보를 찾을 수 없습니다</div>;
      } else {
        // 상품 정보가 있을 경우 상세 페이지 UI를 렌더링합니다.
        return (
          <div className="mt-16 max-w-5xl mx-auto p-4">
            <div className="flex gap-16 items-start">
              {/* 상품 이미지 캐러셀 컴포넌트 */}
              <ListingCarousel listingInfo={listingInfo} s3Urls={s3Urls} />
              {/* 구매 관련 폼 컴포넌트 */}
              <PurchaseForm
                listingInfo={listingInfo}
                initialLike={listingInfo.likes.length > 0}
              />
            </div>
            {/* 상품 설명 컴포넌트 */}
            <ListingDescription description={listingInfo.description} />
            
            {/* 채팅 버튼 컴포넌트: 상품 설명 아래에 위치하며, 판매자 ID를 전달합니다. */}
            <div className="mt-8">
              <ChatButton sellerId={listingInfo.userId} />
            </div>
          </div>
        );
      }
    }
    ```
*   **변경/생성 이유:**
    *   제품 상세 페이지 UI에 '채팅하기' 버튼 추가.
    *   `ChatButton` 컴포넌트를 `ListingDescription` 아래에 배치하여 사용자 혼란 최소화 및 구매 흐름을 방해하지 않음.
    *   서버 컴포넌트에서 `ChatButton` 클라이언트 컴포넌트로 `sellerId`를 전달하여, 클라이언트 컴포넌트가 채팅방 시작 로직을 처리할 수 있도록 함.

### 3.6. `src/app/chat/[chatRoomId]/page.js` 파일 생성 및 수정

*   **파일 경로:** `/Users/admin/Desktop/bootcamp/teamproject/team-1-react/src/app/chat/[chatRoomId]/page.js`
*   **변경/생성 전 요약:** 채팅방 페이지 없음.
*   **변경/생성 후 요약:** `chatRoomId`에 기반하여 실시간 채팅 메시지를 표시하고 전송하는 페이지. Next.js 15 환경의 `params` Promise 처리 및 React Rules of Hooks 규칙 준수.
*   **주요 변경 코드:**
    ```javascript
    // 이 컴포넌트는 클라이언트 측에서 렌더링됩니다.
    'use client';

    // React 훅과 Next.js 관련 훅, Firebase 및 shadcn/ui 컴포넌트들을 import 합니다.
    import { useState, useEffect, useRef } from 'react';
    import { useSession } from 'next-auth/react'; // NextAuth 세션 정보를 가져오기 위해 사용합니다.
    import { useRouter } from 'next/navigation'; // 페이지 라우팅을 위해 사용합니다.
    import { db } from '@/lib/firebase'; // Firebase Firestore 인스턴스를 가져옵니다.
    import {
      collection,
      query,
      orderBy,
      onSnapshot,
      addDoc,
      serverTimestamp,
      doc, // doc 함수 import
      updateDoc, // updateDoc 함수 import
    } from 'firebase/firestore'; // Firestore 관련 함수들을 import 합니다.
    import { Button } from '@/components/ui/button'; // shadcn/ui 버튼 컴포넌트
    import { Input } from '@/components/ui/input'; // shadcn/ui 입력 컴포넌트

    // 채팅 페이지 컴포넌트입니다. URL 파라미터에서 chatRoomId를 받습니다.
    export default function ChatPage({ params }) {
      // URL 파라미터인 params가 Promise일 수 있으므로, 이를 해결하여 chatRoomId를 상태로 관리합니다.
      const [resolvedChatRoomId, setResolvedChatRoomId] = useState(null);
      const { data: session, status } = useSession(); // 현재 사용자의 세션 정보와 인증 상태를 가져옵니다.
      const router = useRouter(); // 라우터 객체를 가져옵니다.
      const [messages, setMessages] = useState([]); // 채팅 메시지 목록을 관리합니다.
      const [newMessage, setNewMessage] = useState(''); // 새 메시지 입력 필드의 값을 관리합니다.
      const messagesEndRef = useRef(null); // 메시지 목록의 맨 아래로 스크롤하기 위한 ref입니다.

      // --- 모든 훅 호출은 여기에 위치해야 합니다. (React Rules of Hooks 준수) ---

      // params Promise를 해결하고 chatRoomId를 상태에 저장하는 useEffect 훅입니다.
      // 이 훅은 컴포넌트가 마운트될 때 한 번 실행되며, params가 변경될 때 다시 실행됩니다.
      useEffect(() => {
        Promise.resolve(params)
          .then(resolved => {
            setResolvedChatRoomId(resolved.chatRoomId);
          })
          .catch(error => {
            console.error("Error resolving params:", error);
            // 오류 발생 시 사용자에게 알리거나 다른 페이지로 리디렉션하는 등의 처리를 할 수 있습니다.
          });
      }, [params]);

      // 메시지 목록이 업데이트될 때마다 자동으로 맨 아래로 스크롤하는 함수입니다.
      const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      };

      // 메시지 목록(messages)이 변경될 때마다 scrollToBottom 함수를 호출합니다.
      useEffect(() => {
        scrollToBottom();
      }, [messages]);

      // Firestore에서 실시간으로 메시지를 가져오는 useEffect 훅입니다.
      // resolvedChatRoomId가 유효할 때만 실행되며, 컴포넌트 언마운트 시 구독을 해제합니다.
      useEffect(() => {
        if (!resolvedChatRoomId) return; // chatRoomId가 아직 해결되지 않았다면 실행하지 않습니다.

        // Firestore의 'chatrooms/{chatRoomId}/messages' 컬렉션에 대한 참조를 가져옵니다.
        const messagesCollection = collection(db, 'chatrooms', resolvedChatRoomId, 'messages');
        // 메시지를 'timestamp' 필드를 기준으로 오름차순 정렬하여 쿼리합니다.
        const q = query(messagesCollection, orderBy('timestamp', 'asc'));

        // onSnapshot을 사용하여 실시간으로 메시지 변경 사항을 구독합니다.
        const unsubscribe = onSnapshot(q, (querySnapshot) => {
          // 스냅샷에서 문서들을 가져와 메시지 객체 배열로 변환합니다.
          const msgs = querySnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));
          setMessages(msgs); // 메시지 상태를 업데이트합니다.
        });

        // 컴포넌트 언마운트 시 Firestore 구독을 해제하는 클린업 함수를 반환합니다.
        return () => unsubscribe();
      }, [resolvedChatRoomId]); // resolvedChatRoomId가 변경될 때마다 다시 구독합니다.

      // 사용자가 채팅 페이지를 보고 있을 때 해당 사용자의 lastRead 타임스탬프를 업데이트합니다.
      useEffect(() => {
        if (!resolvedChatRoomId || !session?.user?.id) return;

        const chatRoomRef = doc(db, 'chatrooms', resolvedChatRoomId);
        const userId = session.user.id;

        const updateLastRead = async () => {
          try {
            await updateDoc(chatRoomRef, {
              [`lastRead.${userId}`]: serverTimestamp(),
            });
          } catch (error) {
            console.error('Error updating lastRead timestamp:', error);
          }
        };

        updateLastRead();

      }, [resolvedChatRoomId, session?.user?.id]); // resolvedChatRoomId 또는 사용자 ID가 변경될 때 실행

      // --- 조건부 렌더링은 모든 훅 호출 이후에 와야 합니다. --- 

      // chatRoomId가 아직 해결되지 않았다면 로딩 메시지를 표시합니다.
      if (!resolvedChatRoomId) {
        return <div>채팅방 정보를 불러오는 중...</div>;
      }

      // 세션 로딩 중일 때 로딩 메시지를 표시합니다.
      if (status === 'loading') {
        return <div>사용자 세션 로딩 중...</div>;
      }

      // 로그인되지 않은 사용자일 경우 로그인 페이지로 리디렉션합니다.
      if (status === 'unauthenticated') {
        router.push('/login');
        return null;
      }

      // 메시지 전송을 처리하는 비동기 함수입니다.
      const handleSendMessage = async (e) => {
        e.preventDefault(); // 폼 제출 시 페이지 새로고침 방지
        // 메시지 내용이 비어있거나 사용자가 로그인되지 않았다면 전송하지 않습니다.
        if (newMessage.trim() === '' || !session) return;

        // 전송할 메시지 데이터를 구성합니다.
        const messageData = {
          text: newMessage,
          // Firestore 서버 타임스탬프를 사용하여 정확한 시간 기록. (클라이언트 시간이 아닌 서버 시간)
          timestamp: serverTimestamp(),
          senderId: session.user.id,
        };

        // 낙관적 업데이트(Optimistic Update): 서버 응답을 기다리지 않고 UI에 메시지를 즉시 추가합니다.
        // 임시 ID와 현재 시간을 부여하여 UI에 빠르게 반영합니다.
        setMessages((prevMessages) => [
          ...prevMessages,
          { ...messageData, id: Date.now().toString(), timestamp: new Date() },
        ]);
        setNewMessage(''); // 입력 필드를 비웁니다.

        try {
          // Firestore의 해당 채팅방 메시지 컬렉션에 새 메시지를 추가합니다.
          const messagesCollection = collection(db, 'chatrooms', resolvedChatRoomId, 'messages');
          await addDoc(messagesCollection, messageData);

          // 채팅방 문서의 lastMessageTimestamp를 업데이트하여 새 메시지가 있음을 알립니다.
          const chatRoomRef = doc(db, 'chatrooms', resolvedChatRoomId);
          await updateDoc(chatRoomRef, {
            lastMessageTimestamp: serverTimestamp(),
          });

        } catch (error) {
          console.error('Error sending message:', error);
          // TODO: 에러 발생 시 낙관적으로 추가했던 메시지를 UI에서 제거하는 등의 에러 처리가 필요합니다.
        }
      };

      // 컴포넌트 렌더링 부분입니다.
      return (
        <div className="flex flex-col h-[calc(100vh-5rem)] max-w-2xl mx-auto my-8 border rounded-lg">
          {/* 메시지 목록을 표시하는 영역입니다. */}
          <div className="flex-grow p-4 overflow-y-auto bg-gray-50">
            {messages.map((msg) => (
              <div
                key={msg.id} // 각 메시지에 고유한 key를 부여합니다.
                // 메시지 보낸 사람에 따라 정렬(오른쪽/왼쪽)을 다르게 합니다.
                className={`flex my-2 ${msg.senderId === session.user.id ? 'justify-end' : 'justify-start'}`}>
                <div
                  // 메시지 보낸 사람에 따라 배경색을 다르게 합니다.
                  className={`px-4 py-2 rounded-lg max-w-xs lg:max-w-md ${msg.senderId === session.user.id ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`}>
                  {msg.text}
                </div>
              </div>
            ))}
            {/* 메시지 목록의 맨 아래로 스크롤하기 위한 빈 div입니다. */}
            <div ref={messagesEndRef} />
          </div>
          {/* 메시지 입력 폼입니다. */}
          <form onSubmit={handleSendMessage} className="flex p-4 border-t">
            <Input
              type="text"
              value={newMessage}
              onChange={(e) => setNewMessage(e.target.value)}
              placeholder="메시지를 입력하세요..."
              className="flex-grow"
            />
            <Button type="submit" className="ml-4">전송</Button>
          </form>
        </div>
      );
    }
    ```

## 4. 현재 상태

*   **핵심 채팅 기능:** 텍스트 기반 1:1 채팅 기능의 클라이언트 및 서버 로직이 모두 구현되었으며, 메시지 전송 및 실시간 동기화가 가능합니다.
*   **알림 기반 마련:** Firestore `chatrooms` 문서에 `lastMessageTimestamp` 및 `lastRead` 필드 업데이트 로직이 구현 완료되어, 읽지 않은 메시지 수를 계산할 수 있는 기반이 마련되었습니다.
*   **Hooks 규칙 준수:** React Rules of Hooks 오류가 해결되어 컴포넌트의 안정성이 확보되었습니다.
*   **다음 단계 직전:** `ChatContext`를 생성하여 애플리케이션 전반에 채팅 관련 상태를 공유하기 직전 상태입니다.

## 5. 다음 작업 (Next Steps)

현재 구현된 기능을 기반으로 사용자 알림 및 채팅방 목록 관리를 위한 다음 단계 작업들입니다.

*   **<ins>필수: `ChatContext` 생성 및 통합</ins> (보류되었던 작업)**
    *   **파일 생성:** `src/context/ChatContext.js` 파일을 생성합니다.
    *   **ContextProvider 구현:** `ChatProvider` 컴포넌트 내에서 현재 사용자가 참여하고 있는 모든 채팅방 목록(`userChats`)을 Firestore에서 가져오고, 각 채팅방의 `lastRead`와 `lastMessageTimestamp`를 비교하여 총 읽지 않은 메시지 수(`unreadChatsCount`)를 계산합니다.
    *   **애플리케이션 통합:** `src/app/providers.js` 파일 (또는 최상위 `layout.js` 파일)에서 `ChatContext.Provider`로 자식(children) 컴포넌트들을 감싸, 모든 컴포넌트에서 채팅 관련 상태에 접근할 수 있도록 합니다.
*   **네비게이션 바 알림 구현:**
    *   **파일 수정:** `src/components/Navbar.js` 파일.
    *   **Context 사용:** `useChat` 훅을 사용하여 `ChatContext`에서 `unreadChatsCount`를 가져옵니다.
    *   **UI 표시:** `unreadChatsCount`가 0보다 크면 알림 배지(Badge)를 네비게이션 바의 채팅 아이콘 옆에 표시합니다.
*   **"내 채팅" 페이지 구현:**
    *   **파일 생성:** `src/app/my/chats/page.js` 파일 (또는 유사한 경로).
    *   **Context 사용:** `useChat` 훅을 사용하여 `ChatContext`에서 `userChats` 목록을 가져옵니다.
    *   **UI 표시:** 각 채팅방의 마지막 메시지, 상대방 이름 등을 포함한 목록을 렌더링합니다.
    *   **링크 추가:** 각 채팅방 목록 아이템 클릭 시 해당 `/chat/[chatRoomId]` 페이지로 이동하도록 라우팅을 구현합니다.
*   **추가 기능 (선택 사항):**
    *   채팅 페이지에 상대방 이름, 프로필 사진 등 사용자 정보 표시.
    *   이미지/파일 업로드 기능 (현재는 텍스트만 전송 가능).
    *   실시간 푸시 알림 (Firebase Cloud Messaging 통합).
    *   채팅방 목록 검색 및 필터링 기능.
    *   메시지 시간 포맷팅 (예: "방금", "10분 전", "오전 10:30").

---
